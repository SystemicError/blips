+Finish animation image placeholders.
+Do the same for sounds.
+Write keys, campaign file.
+Start coding?
+Finish media_set definitions.
+Finish campaign definition.
+Write world_tile
+Fix the whitespace problem!  fscanf(fp,"%s\n",buffer); stops at the first whitespace!  Replace with fgets.
+Make a new class called "string_map."  This will be a map in the data structure sense, to associate a string with a void pointer.  Use this to encapsulate all the damn keys hanging around.
+Rewrite statics support:
	Could add int static field to creatures.  Objects of type static would appear in normal key, would need separate definitons.  I like this solution because it doesn't introduce yet another map, and it's not a huge hassle to have static objects occasionally be copies of non-static ones.
	+Also, new keyword.  Call it enum spawn_trigger {enter, clear} and bool respawn.
	+Rewrite *_type.* files to accommodate these new fields.
+Figure out how we're going to deal with object keys.  Will world tiles just read the map strings, letting the game translate?  Seems reasonable, actually.
+Get working on loading pr_types and ai_types in blips_game.
	+pr_types
	+ai_types
+Insert code for player creatures.
	+give player creatures a special array in blips_game.
	+Add code to remove special array in destructor, create it in constructor.
+Get rendering of objects working.
	+Br
	+Co
	+Cr
	+Pr needs general testing.
+Convert x_in_cell, y_in_cell to type double.


+Write breakable,collectible,creature,projectile
-Integrate these into game, gui.
	+Give game a function called spawn() or something, which causes current world tile's list of objects to be entered into present br/co/cr lists.
	-Give game a function called despawn() or something, which removes all non-player objects in preparation for spawn().
	-Have both spawn() and despawn() called by change_tile(maze_direction).
	-Have change_tile(maze_direction) triggered by [bool] player_leaving_tile().
-Create control scheme (AI/player).

-Map out ai structure.  Does a type called ai ever get instantiated beyond ai_type?  Seems necessary for patrol_ns/ew, wander.




-Not to mention spawing projectiles.

-Test maze/barrier loading. (print it!)

-Consider a blips_input_reader which is configured by a text file.



-Answer this:  if animations are separate from function, how do we decide how long to allow them to persist in the game before deletion?  Give blips_game function ptrs projectile_released(), creature_released(), and breakable_released().  The gui will implement them and decide when to let go of them (when animations are done).

-Collision control.  Also done with fptrs.



-Write blips_game_apply_ai_type_to_creature()
	-move_goal
	-aim_goal
	-fire_goal

-Add sound playback.


-Center creature, projectile images on their location.  This will solve the spawn offset problem with projectile rendering.
